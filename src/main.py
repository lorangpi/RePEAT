import argparse
from cmath import exp
import collections
import json
import copy

from antlr4 import *
from dist.FormulaLexer import FormulaLexer
from dist.FormulaParser import FormulaParser
from dist.FormulaVisitor import FormulaVisitor

from AtomicFormula import AtomicFormula
from NegationFormula import NegationFormula
from ConsjunctionFormula import ConjunctionFormula
from DisjunctionFormula import DisjunctionFormula
from ModalOpFormula import ModalOpFormula
from EpistemicState import EpistemicState
from EpistemicEvent import EpistemicEvent
from Learner import Learner

import gym
from stable_baselines3 import PPO
from stable_baselines3.common.env_checker import check_env
from gym.envs.registration import register


register(
	id='BirthdayPresent-v0',
	entry_point='env.epistemic_env:Birthdaypresent',
	max_episode_steps=10)

register(
	id='PinkPanther-v0',
	entry_point='env.epistemic_env:Pinkpanther',
	max_episode_steps=10)


class MyVisitor(FormulaVisitor):
	def visitAtom(self, ctx):
		return AtomicFormula(ctx.getText())

	def visitConjunction(self, ctx):
		left = self.visit(ctx.formula()[0])
		right = self.visit(ctx.formula()[1])
		return ConjunctionFormula(left, right)

	def visitDisjunction(self, ctx):
		left = self.visit(ctx.formula()[0])
		right = self.visit(ctx.formula()[1])
		return DisjunctionFormula(left, right)

	def visitNegation(self, ctx):
		return NegationFormula(self.visit(ctx.formula()))

	def visitModal_operator(self, ctx):
		agent = self.visit(ctx.formula()[0])
		formula = self.visit(ctx.formula()[1])
		return ModalOpFormula(agent, formula)

	def visitParens(self, ctx):
		return str(self.visit(ctx.formula()))


def read_formula(data):
	"""
	read_formula uses a parser generator (whose syntax is defined in Formula.g4) and reads the string input

	:param data: str input of the formula
	:return: the output pf object instances generated by the parser from MyVisitor class.
	""" 
	# lexer
	lexer = FormulaLexer(data)
	stream = CommonTokenStream(lexer)
	# parser
	parser = FormulaParser(stream)
	tree = parser.formula()
	# evaluator
	visitor = MyVisitor()
	output = visitor.visit(tree)
	return output

def breadth_first_search_planner(initial_state, events_list, goal, args):
	"""
	Operate a breadth first search on the epistemic planning problem

	:param initial_state: EpistemicState object - the initial state
	:param events_list: list - the list of all existing events
	:param goal: list - a list of formulas to achieve as goal
	:param arg: parser - the args from the parser

	:return: plan: list - the list of actions making the plan that satisfies the goal conditions in so*plan
	""" 
	# Initialize a priority queue
	queue = [(initial_state, [], [initial_state])]
	buffer = [initial_state]
	final_plan = []
	# Starts the search engine
	truth_list = []
	for formula in goal:
		truth = check_formulas(initial_state, [formula], args=args, out=True)
		truth_list.append(truth)
	if all(truth_list):
		return []
	while len(queue) > 0:
		queue_buffer = []
		# 2 while loops in order to reorganize the .append .pop order (so that all the list gets browsed every time and not just pop the last one continuously)
		while len(queue) > 0:
			trial = queue.pop()
			state = trial[0]
			plan = trial[1]
			states_list = trial[2]
			for event in events_list:
				state_copy = copy.deepcopy(state)
				# if action is applicable in state
				if event.rule_Wprime(state_copy, check_Ed=True): 
					#print(event.Ed)
					if event.Ed[0] not in plan:
						state_copy = copy.deepcopy(state)
						new_state = EpistemicState(event.compute(state_copy), display=args.state)
						truth_list = []
						plan_event = plan.copy()
						plan_event.append(event)#(event.Ed[0])
						states_list_copy = states_list.copy()
						states_list_copy.append(new_state)
						if args.visual_search:
							print("The computed plan is: ", [event.Ed[0] for event in plan_event], '\n')
						for formula in goal:
							truth = check_formulas(new_state, [formula], args=args, out=True)
							truth_list.append(truth)
						if all(truth_list):
							return plan_event, states_list_copy
						if not (collections.Counter(new_state.W) == collections.Counter(state.W) or new_state.Wd == [""]):
							queue_buffer.append((new_state, plan_event, states_list_copy))
		queue = queue_buffer
		if args.visual_search:
			if len(queue) > 0:
				print('\n----------------------------Search depth is at layer %d----------------------------\n'%(len(queue[0][1])))
			else:
				print("\n--------------The Agent Failed to find a Plan Satisfaying the goal-----------------\n")
				return
	return plan

def check_formulas(epistemic_state, formulas, args, out=False):
	"""
	Check the truth of a formula in an epistemic state

	:param epistemic_state: EpistemicState object - the state in which to check the formula
	:param formulas: list - the list of potential formulas to check
	:param arg: parser - the args from the parser
	:param out: bool - whether to return the truth value of the formula in the state

	:return: truth: bool - the truth value of the formula in the state
	""" 
	# for loop to read (lexer, parser, evaluator) and check if the formulas hold in the state 
	buffer = []
	for x in formulas:
		data =  InputStream(x)
		output = read_formula(data)
		# Check formulas in state
		truth = epistemic_state.truth(output)[1]
		if out:
			return truth
		elif args.state != None:
			print("Truth of formula %s is: "%(output), truth)
			buffer.append("Truth of formula %s is: %s\n"%(output, truth))
		else:
			print(truth)
			buffer.append("%s\n"%(truth))
	# Saves results in a file named 'stored_example.txt'
	with open('stored_example.txt', 'w') as f:
		f.writelines(buffer)

def check_strongplan(plan, expected_states, goal, initial_state=None):
	"""
	Runs the plan in the environment, if everything works as expected returns True

	:param plan: list - the list of the ordered actions in the plan
	:param expected_states: list - the list of the expected epistemic states to reach after each action
	:param initial_state: EpistemicState object - the initial state if given, else is expected_states[0]

	:return: truth: bool, i: int - If a plan is successful, if not the index of the action that failed
	""" 
	# for loop to read (lexer, parser, evaluator) and check if the formulas hold in the state 

	if initial_state == None:
		new_state = expected_states[0]
	else:
		new_state = initial_state

	for i, action in enumerate(plan):
		# If the action is a learned policy integrated as tuple (pre, policy, effects)
		if type(action) == tuple:
			action_replaced = expected_states[i+1].Wd[0].replace(expected_states[i].Wd[0], '')
			print("Executing Policy replacing %s:::" %action_replaced)
			preconditions = action[0]
			policy = action[1]
			effects = action[2]
			old_state = copy.deepcopy(new_state)
			# Check if the action is applicable in the currect state
			env_plan = gym.make(env_str, initial_state=preconditions, goal_state=effects, NotLearning=True)
			env_real = gym.make(env_str, initial_state=new_state, goal_state=effects, NotLearning=True)

			obs_expected = env_plan.reset()
			obs_real = env_real.reset()

			if (obs_real!=obs_expected).any(): #if not applicable, break
				print("Policy replacing %s FAILED (is not applicable).\n" %action_replaced)
				return False, i, old_state
			else:
				success = False
				done = False

				obs = env_real.reset()
				trials = 0
				while not done:
					action = policy.predict(obs)[0]
					for key, value in env_real.actions_id.items():
						if action == value:
							print(key)
					obs, _, done, info = env_real.step(action)
					success = info["is_success"]
					trials += 1
					if trials > 30:
						done = True
						break
				if done and not success:
					print("Policy replacing %s FAILED (wrong effects).\n" %action_replaced)
					return False, i, old_state
				elif i == len(plan)-1:
					truth_list = list()
					new_state = info["Epistemic_state"]
					for formula in [goal]:
						truth = check_formulas(new_state, [formula], args=args, out=True)
						truth_list.append(truth)
					if not(all(truth_list)):
						print("Policy replacing %s FAILED (wrong effects).\n" %action_replaced)
						return False, i, new_state
				else:
					print("<Success>\n")
					new_state = info["Epistemic_state"]

		# Else if the action is an epistemic event
		else:
			env_plan = gym.make(env_str, initial_state=expected_states[i+1], goal_state=expected_states[i+1], NotLearning=True)
			env_real = gym.make(env_str, initial_state=new_state, goal_state=EpistemicState(action.compute(new_state), display=args.state), NotLearning=True)

			obs_real = env_real.reset()
			obs_expected = env_plan.reset()

			action_id = env_plan.actions_id[action.Ed[0]]
			obs_real, _, _, info = env_real.step(action_id)
			old_state = copy.deepcopy(new_state)
			new_state = EpistemicState(action.compute(new_state), display=args.state)
			print("Executing %s:::" %action.Ed[0])


			if (obs_real!=obs_expected).any():
				print("Action %s FAILED." %(plan[i].Ed[0]))
				return False, i, old_state
			elif i == len(plan)-1:
				truth_list = list()
				new_state = info["Epistemic_state"]
				for formula in [goal]:
					truth = check_formulas(new_state, [formula], args=args, out=True)
					truth_list.append(truth)
				if not(all(truth_list)):
					print("Action %s FAILED." %(plan[i].Ed[0]))
					return False, i, old_state
			print("<Success>\n")
	return True, None, new_state



if __name__ == "__main__":
	"""
	main checks if a file is given in the parser, and if it is a Formula, Model or Event file and then saves and display either respectively
	the formula, the truth of the formula in the state and the truth of the formulas in the state resulting in the computation of the input state and 
	the event.

	:param None
	:arg -f --file. Read a file as input.
	:arg -s --state. If True Prints out the epistemic state and the epistemic event.
	:return: None. Displays the results and saves a file out of it.
	""" 
	# Initialize parser
	parser = argparse.ArgumentParser()
	# Adding optional argument
	parser.add_argument("-f", "--file", help = "Read a file as input.")
	parser.add_argument("-s", "--state", help = "If True Prints out the epistemic state")
	parser.add_argument("-v", "--visual_search", help = "If True Prints out search information")
	# Read arguments from command line
	args = parser.parse_args()

	# File mode (file given as arg)
	if args.file != None:
		# Reads input file
		contents = []
		for line in open(args.file):
			li=line.strip()
			if not li.startswith("#"):
				contents.append(line.rstrip())
		# if the file given is an Epistemic State (check formulas in it) 
		# or an Epistemic Event + Epistemic State (compute and check formulas in resulting state)

		#Search mode
		if contents[0] == "Search":
			goal = contents[-2]
			env_str = contents[-1]
			state = json.loads(contents[1])
			# Creates the Epistemic State instance (bool variable only to display it if put in argument)
			if args.state != None:
				EpistemicState_S = EpistemicState(state, True)
			else:
				EpistemicState_S = EpistemicState(state)
			EpistemicInitialState_S = copy.deepcopy(EpistemicState_S)
			# Creates the Epistemic Events instances - General event with Ed = E - (bool variable only to display it if put in argument)
			events_list = []
			for i in range(2, len(contents)-2):
				event = json.loads(contents[i])
				events_list.append(EpistemicEvent(event))
			# Search a plan with BFS
			if args.visual_search:
				print("\nThe goal is: ", goal)
				plan, expected_states = breadth_first_search_planner(EpistemicState_S, events_list, [goal], args=args)
				if plan != None:
					print('\n----------------------------Congratz Agent, you found the plan! ----------------------------\n Plan: ', [event.Ed[0] for event in plan])
				else:
					print("\n-----------------------------------------------\n\tThe Plan is:\n-----------------------------------------------\n\n")
					print('\n\n Plan: ', plan)
			else:
				plan, expected_states = breadth_first_search_planner(EpistemicState_S, events_list, [goal], args=args)
				print("\n\n-----------------------------------------------\n\tThe Plan is:\n-----------------------------------------------\n\n")
				print('Plan Ï€ = ', [event.Ed[0] for event in plan], '\n')

			#"""
			# Reads input file
			contents = []
			for line in open(args.file + "RL"):
				li=line.strip()
				if not li.startswith("#"):
					contents.append(line.rstrip())
			initial_state = json.loads(contents[-1])
			EpistemicInitialState_S = EpistemicState(initial_state)
			new_state = copy.deepcopy(EpistemicInitialState_S)
			#"""
			#new_state = EpistemicInitialState_S

			last_state = expected_states[-1]

			print("\n\n-----------------------------------------------\n\tExecuting Plan.\n-----------------------------------------------\n\n")
			strong_plan = False
			while not strong_plan:
				
				strong_plan, failed_step, failed_state = check_strongplan(plan, expected_states, goal, initial_state=new_state)
				if not strong_plan:
					print("\nHmmm... \nIt seems like the plan didn't work this time. Something must have changed. \nLet's learn how to handle this novelty!\n\n")
					print("----------------------------------------------\n\tNovelty: Launching Learner.\n----------------------------------------------\n")
					if failed_step == 0:
						failed_state = new_state
						goal_state = expected_states[failed_step+1]
					elif failed_step == len(plan)-1:
						goal_state = goal
					else:
						goal_state = expected_states[failed_step+1]
					
					learner = Learner(failed_state=failed_state, goal_state=goal_state, env=env_str, display=args.visual_search)
					learned_policy, policy = learner.learn()
				

					if learned_policy:
						tuple_policy = (failed_state, policy, goal_state)
						plan[failed_step] = tuple_policy
						print("\n-----------------------------------------------\n\tPolicy Learned.\n-----------------------------------------------\n\n")
						print("-----------------------------------------------\n\tExecuting New Plan.\n-----------------------------------------------\n\n")
					else:
						print("\nFailure to Learn a strong plan.")
						break
		
			truth_list = list()       
			for formula in [goal]:
				truth = check_formulas(failed_state, [formula], args=args, out=True)
				truth_list.append(truth)
			if all(truth_list) and strong_plan:
				print("\n-----------------------------------------------\n\tThe Plan is strong again.\n-----------------------------------------------\n\n")
				print("Bravo! Your plan was successful")
			elif not(all(truth_list)):
				print("\nHmmm... \nIt seems like the plan didn't work this time. Something must have changed. \nLet's learn how to handle this novelty!\n\n")
				print("----------------------------------------------\n\tNovelty: Launching Learner.\n----------------------------------------------\n")
				strong_plan = False
				goal_state = last_state
				learner = Learner(failed_state=failed_state, goal_state=goal_state, env=env_str, display=args.visual_search)
				learned_policy, policy = learner.learn()

				if learned_policy:
					tuple_policy = (failed_state, policy, goal_state)
					plan[-1] = tuple_policy
					print("\n-----------------------------------------------\n\tPolicy Learned.\n-----------------------------------------------\n\n")
					print("-----------------------------------------------\n\tExecuting New Plan.\n-----------------------------------------------\n\n")
					strong_plan, failed_step, failed_state = check_strongplan(plan, expected_states, goal, initial_state=new_state)
				else:
					print("\nFailure to Learn a strong plan.")
				if all(truth_list) and strong_plan:
					print("\n-----------------------------------------------\n\tThe Plan is strong again.\n-----------------------------------------------\n\n")
					print("Bravo! Your plan was successful")
				else:
					print("\nFailure to Learn a strong plan.")
			else:
				print("\nFailure to Learn a strong plan.")

	else: # No file submitted as flag
		while 1:
			data =  InputStream(input(">>> "))
			output = read_formula(data)
			print(output)
