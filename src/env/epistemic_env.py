import numpy as np
import gym
from gym import spaces
import random
import copy

from antlr4 import *
from dist.FormulaLexer import FormulaLexer
from dist.FormulaParser import FormulaParser
from dist.FormulaVisitor import FormulaVisitor

from AtomicFormula import AtomicFormula
from NegationFormula import NegationFormula
from ConsjunctionFormula import ConjunctionFormula
from DisjunctionFormula import DisjunctionFormula
from ModalOpFormula import ModalOpFormula
from EpistemicState import EpistemicState
from EpistemicEvent import EpistemicEvent

class MyVisitor(FormulaVisitor):
	def visitAtom(self, ctx):
		return AtomicFormula(ctx.getText())

	def visitConjunction(self, ctx):
		left = self.visit(ctx.formula()[0])
		right = self.visit(ctx.formula()[1])
		return ConjunctionFormula(left, right)

	def visitDisjunction(self, ctx):
		left = self.visit(ctx.formula()[0])
		right = self.visit(ctx.formula()[1])
		return DisjunctionFormula(left, right)

	def visitNegation(self, ctx):
		return NegationFormula(self.visit(ctx.formula()))

	def visitModal_operator(self, ctx):
		agent = self.visit(ctx.formula()[0])
		formula = self.visit(ctx.formula()[1])
		return ModalOpFormula(agent, formula)

	def visitParens(self, ctx):
		return str(self.visit(ctx.formula()))

class Birthdaypresent(gym.GoalEnv):
	"""
	Custom Environment that follows gym interface.
	This is the BirthdayPresent epistemic env. 
	"""
	def __init__(self, initial_state, goal_state, NotLearning=False, display=False):
		super(Birthdaypresent, self).__init__()

		#
		self.initial_state = initial_state
		self.state = initial_state
		#
		self.goal_state = goal_state
		self.NotLearning = NotLearning
		self.display = display

		# Define action and observation space. They must be gym.spaces objects

		# Actions
		self.actions_id = dict()
		self.manipulation_actions_id = { 'GoFatherHomePO1': 0, 'GoFatherHomePO2': 1, 'GoFatherHomePO3': 2, 'GoFatherPO1Home': 3, 'GoFatherPO2Home': 4, 'GoFatherPO3Home': 5,
										 'GoFatherPO1PO2': 6, 'GoFatherPO1PO3': 7, 'GoFatherPO2PO1': 8, 'GoFatherPO2PO3': 9, 'GoFatherPO3PO1': 10, 'GoFatherPO3PO2': 11,
										 'TryPickUpPresentPO1': 12, 'TryPickUpPresentPO2': 13, 'TryPickUpPresentPO3': 14, 'WrapPresent': 15,}                                       
		self.actions_id.update(self.manipulation_actions_id)

		# Action space
		self.action_space = spaces.Discrete(16)

		# Observation
		# The observation will consist of the location of the agent (home h, LaPoste l, Friend f, Brother b), 
		# and other propositions: Has(Father, Present)=s, Wrapped(Present)=w, HasCkeched(LaPoste)=s1, HasCkeched(Friend))=s2, HasCkeched(Brother)=s3,
		self.locations = {"h":0, "b":0, "l":0, "f":0}
		self.propositions = {"s":0, "s1":0, "s2":0, "w":0}#, "s3":0}
		self.observation = {**self.locations, **self.propositions}
		self.goal = self.take_obs(goal_state)
		self.goal_dict = self.observation

		for key in self.observation:
			if self.check_formulas(self.initial_state, [key]):
				self.observation[key] = 1

		# Observation space
		self.low = np.asarray([0] *len(self.observation)).astype(np.float64)
		self.high = np.asarray([1] *len(self.observation)).astype(np.float64)
		self.observation_space = spaces.Box(self.low, self.high, dtype=np.float64)

	def read_formula(self, data):
		"""
		read_formula uses a parser generator (whose syntax is defined in Formula.g4) and reads the string input

		:param data: str input of the formula
		:return: the output pf object instances generated by the parser from MyVisitor class.
		""" 
		# lexer
		lexer = FormulaLexer(data)
		stream = CommonTokenStream(lexer)
		# parser
		parser = FormulaParser(stream)
		tree = parser.formula()
		# evaluator
		visitor = MyVisitor()
		output = visitor.visit(tree)
		return output

	def check_formulas(self, epistemic_state, formulas):
		"""
		Check the truth of a formula in an epistemic state

		:param epistemic_state: EpistemicState object - the state in which to check the formula
		:param formulas: list - the list of potential formulas to check
		:param arg: parser - the args from the parser
		:param out: bool - whether to return the truth value of the formula in the state

		:return: truth: bool - the truth value of the formula in the state
		""" 
		# for loop to read (lexer, parser, evaluator) and check if the formulas hold in the state 
		for x in formulas:
			data =  InputStream(x)
			output = self.read_formula(data)
			# Check formulas in state
			truth = epistemic_state.truth(output)[1]
			return truth


	def take_obs(self, state):
		self.observation = {**self.locations, **self.propositions}
		for key in self.observation:
			if self.check_formulas(state, [key]):
				self.observation[key] = 1
		obs = np.asarray([self.observation[item] for item in sorted(self.observation)]).astype(np.float64)
		return obs

	def reset(self):
		"""
		Important: the observation must be a numpy array
		:return: (np.array) 
		"""
		# Initialize the agent at the failed state
		self.state = self.initial_state
		
		# here we convert to float64 to make it more general (in case we want to use continuous actions)
		return self.take_obs(self.initial_state)

	def step(self, action_id):

		info = {}
		success = False
		done = False

		if action_id == self.actions_id['GoFatherHomePO1']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherHomePO1"], "E":["GoFatherHomePO1"], "Ref":[["GoFatherHomePO1","GoFatherHomePO1"]], "pre":[["GoFatherHomePO1",["h"]]], "post":[["GoFatherHomePO1",["l", "¬h"]]]}
		elif action_id == self.actions_id['GoFatherHomePO2']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherHomePO2"], "E":["GoFatherHomePO2"], "Ref":[["GoFatherHomePO2","GoFatherHomePO2"]], "pre":[["GoFatherHomePO2",["h"]]], "post":[["GoFatherHomePO2",["f", "¬h"]]]}
		elif action_id == self.actions_id['GoFatherHomePO3']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherHomeP03"], "E":["GoFatherHomeP03"], "Ref":[["GoFatherHomeP03","GoFatherHomeP03"]], "pre":[["GoFatherHomeP03",["h"]]], "post":[["GoFatherHomeP03",["b", "¬h"]]]}
		elif action_id == self.actions_id['GoFatherPO1Home']: 
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherPO1Home"], "E":["GoFatherPO1Home"], "Ref":[["GoFatherPO1Home","GoFatherPO1Home"]], "pre":[["GoFatherPO1Home",["l"]]], "post":[["GoFatherPO1Home",["h", "¬l"]]]}
		elif action_id == self.actions_id['GoFatherPO2Home']: 
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherPO2Home"], "E":["GoFatherPO2Home"], "Ref":[["GoFatherPO2Home","GoFatherPO2Home"]], "pre":[["GoFatherPO2Home",["f"]]], "post":[["GoFatherPO2Home",["h", "¬f"]]]}
		elif action_id == self.actions_id['GoFatherPO3Home']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherPO3Home"], "E":["GoFatherPO3Home"], "Ref":[["GoFatherPO3Home","GoFatherPO3Home"]], "pre":[["GoFatherPO3Home",["b"]]], "post":[["GoFatherPO3Home",["h", "¬b"]]]}
		elif action_id == self.actions_id['GoFatherPO1PO2']:  
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherPO1PO2"], "E":["GoFatherPO1PO2"], "Ref":[["GoFatherPO1PO2","GoFatherPO1PO2"]], "pre":[["GoFatherPO1PO2",["l"]]], "post":[["GoFatherPO1PO2",["f", "¬l"]]]}
		elif action_id == self.actions_id['GoFatherPO1PO3']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherPO1PO3"], "E":["GoFatherPO1PO3"], "Ref":[["GoFatherPO1PO3","GoFatherPO1PO3"]], "pre":[["GoFatherPO1PO3",["l"]]], "post":[["GoFatherPO1PO3",["b", "¬l"]]]}
		elif action_id == self.actions_id['GoFatherPO2PO1']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherPO2PO1"], "E":["GoFatherPO2PO1"], "Ref":[["GoFatherPO2PO1","GoFatherPO2PO1"]], "pre":[["GoFatherPO2PO1",["f"]]], "post":[["GoFatherPO2PO1",["l", "¬f"]]]}
		elif action_id == self.actions_id['GoFatherPO2PO3']:   
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherPO2PO3"], "E":["GoFatherPO2PO3"], "Ref":[["GoFatherPO2PO3","GoFatherPO2PO3"]], "pre":[["GoFatherPO2PO3",["f"]]], "post":[["GoFatherPO2PO3",["b", "¬f"]]]}
		elif action_id == self.actions_id['GoFatherPO3PO1']: 
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherPO3PO1"], "E":["GoFatherPO3PO1"], "Ref":[["GoFatherPO3PO1","GoFatherPO3PO1"]], "pre":[["GoFatherPO3PO1",["b"]]], "post":[["GoFatherPO3PO1",["l", "¬b"]]]}  
		elif action_id == self.actions_id['GoFatherPO3PO2']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["GoFatherPO3PO2"], "E":["GoFatherPO3PO2"], "Ref":[["GoFatherPO3PO2","GoFatherPO3PO2"]], "pre":[["GoFatherPO3PO2",["b"]]], "post":[["GoFatherPO3PO2",["f", "¬b"]]]}
		elif action_id == self.actions_id['TryPickUpPresentPO1']:
			if self.check_formulas(self.state, ['pl']):
				event = {"Eps":["E","Ref","pre","post"], "Ed":["TryPickUpPresentPO1"], "E":["TryPickUpPresentPO1","TryPickUpPresentPO1fails"], "Ref":[["TryPickUpPresentPO1","TryPickUpPresentPO1"],["TryPickUpPresentPO1fails","TryPickUpPresentPO1fails"]], "pre":[["TryPickUpPresentPO1",["l","pl","¬s"]],["TryPickUpPresentPO1fails",["l","¬s"]]], "post":[["TryPickUpPresentPO1",["s","s1","¬pl"]],["TryPickUpPresentPO1fails",["s1"]]]}
			else:
				event = {"Eps":["E","Ref","pre","post"], "Ed":["TryPickUpPresentPO1fails"], "E":["TryPickUpPresentPO1","TryPickUpPresentPO1fails"], "Ref":[["TryPickUpPresentPO1","TryPickUpPresentPO1"],["TryPickUpPresentPO1fails","TryPickUpPresentPO1fails"]], "pre":[["TryPickUpPresentPO1",["l","pl","¬s"]],["TryPickUpPresentPO1fails",["l","¬s"]]], "post":[["TryPickUpPresentPO1",["s","s1","¬pl"]],["TryPickUpPresentPO1fails",["s1"]]]}
		elif action_id == self.actions_id['TryPickUpPresentPO2']:
			if self.check_formulas(self.state, ['pf']):
				event = {"Eps":["E","Ref","pre","post"], "Ed":["TryPickUpPresentPO2"], "E":["TryPickUpPresentPO2","TryPickUpPresentPO2fails"], "Ref":[["TryPickUpPresentPO2","TryPickUpPresentPO2"],["TryPickUpPresentPO2fails","TryPickUpPresentPO2fails"]], "pre":[["TryPickUpPresentPO2",["f","pf","¬s"]],["TryPickUpPresentPO2fails",["f","¬s"]]], "post":[["TryPickUpPresentPO2",["s","s2","¬pf"]],["TryPickUpPresentPO2fails",["s2"]]]}
			else:
				event = {"Eps":["E","Ref","pre","post"], "Ed":["TryPickUpPresentPO2fails"], "E":["TryPickUpPresentPO2","TryPickUpPresentPO2fails"], "Ref":[["TryPickUpPresentPO2","TryPickUpPresentPO2"],["TryPickUpPresentPO2fails","TryPickUpPresentPO2fails"]], "pre":[["TryPickUpPresentPO2",["f","pf","¬s"]],["TryPickUpPresentPO2fails",["f","¬s"]]], "post":[["TryPickUpPresentPO2",["s","s2","¬pf"]],["TryPickUpPresentPO2fails",["s2"]]]}
		elif action_id == self.actions_id['TryPickUpPresentPO3']:
			if self.check_formulas(self.state, ['pb']):
				event = {"Eps":["E","Ref","pre","post"], "Ed":["TryPickUpPresentPO3"], "E":["TryPickUpPresentPO3","TryPickUpPresentPO3fails"], "Ref":[["TryPickUpPresentPO3","TryPickUpPresentPO3"],["TryPickUpPresentPO3fails","TryPickUpPresentPO3fails"]], "pre":[["TryPickUpPresentPO3",["b","pb","¬s"]],["TryPickUpPresentPO3fails",["b","¬s"]]], "post":[["TryPickUpPresentPO3",["s","s3","¬pb"]],["TryPickUpPresentPO3fails",["s3"]]]}
			else:
				event = {"Eps":["E","Ref","pre","post"], "Ed":["TryPickUpPresentPO3fails"], "E":["TryPickUpPresentPO3","TryPickUpPresentPO3fails"], "Ref":[["TryPickUpPresentPO3","TryPickUpPresentPO3"],["TryPickUpPresentPO3fails","TryPickUpPresentPO3fails"]], "pre":[["TryPickUpPresentPO3",["b","pb","¬s"]],["TryPickUpPresentPO3fails",["b","¬s"]]], "post":[["TryPickUpPresentPO3",["s","s3","¬pb"]],["TryPickUpPresentPO3fails",["s3"]]]}
		elif action_id == self.actions_id['WrapPresent']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["WrapPresent"], "E":["WrapPresent"], "Ref":[["WrapPresent","WrapPresent"]], "pre":[["WrapPresent",["s","¬w"]]], "post":[["WrapPresent",["w"]]]}


		epistemic_event = EpistemicEvent(event)
		state_copy = copy.deepcopy(self.state)

		if epistemic_event.rule_Wprime(state_copy, check_Ed=True): # If event applicable in current state
			self.state = EpistemicState(epistemic_event.compute(state_copy))
			obs = self.take_obs(self.state)
			comparison = self.observation == self.goal_dict # Test if reached the goal
			reward = 100. if comparison else -1.
			done = (reward == 100.)
			success = done
		else:
			obs = self.take_obs(self.state)
			reward = -10.

		info = {}
		if self.display:
			if success:
				print('----------------------Congratz Robot! You succeded!---------------------------')
			else:
				print('< It happens to fail! >')
		info.update({'is_success': success}) 	# Optionally we can pass additional info, we are not using that for now

		if self.NotLearning:
			info.update({"Epistemic_state": self.state})

		return obs, reward, done, info


	def close(self):
		pass



class Pinkpanther(gym.GoalEnv):
	"""
	Custom Environment that follows gym interface.
	This is the Pink Panther epistemic env. 
	"""
	def __init__(self, initial_state, goal_state, NotLearning=False, display=False):
		super(Pinkpanther, self).__init__()

		#
		self.initial_state = initial_state
		self.state = initial_state
		#
		self.goal_state = goal_state
		self.NotLearning = NotLearning
		self.display = display

		# Define action and observation space. They must be gym.spaces objects


		# Actions
		self.actions_id = dict()
		self.manipulation_actions_id = { 'Take_left': 0, 'Take_right': 1, 'Flick_light': 2, 'Throw_pebble': 3, 'MoveIn': 4, 'MoveOut': 5,
										 'Cut_electricity': 6, 'Use_battery': 7, 'Throw_pebble_check_fox': 8}                                       
		self.actions_id.update(self.manipulation_actions_id)

		# Action space
		self.action_space = spaces.Discrete(9)


		# Observation
		# The observation will consist of the location of the agent (PinkP_outside_vault = o, red_fox_outside_vault = f), 
		# and other propositions: Diamond_Right = r, Diamond_Left = ¬r, Light_inside_vault = l, electricity = e
		self.locations = {"o":0, "f":0}
		self.propositions = {"r":0, "d":0, "l":0, "v":0, "e":0, "Opf(d)":0, "Opp(¬(Opf(d)))":0}
		self.observation = {**self.locations, **self.propositions}
		self.goal = self.goal_state if type(self.goal_state) == str else self.take_obs(goal_state) 

		for key in self.observation:
			if self.check_formulas(self.initial_state, [key]):
				self.observation[key] = 1

		# Observation space
		self.low = np.asarray([0] *len(self.observation)).astype(np.float64)
		self.high = np.asarray([1] *len(self.observation)).astype(np.float64)
		self.observation_space = spaces.Box(self.low, self.high, dtype=np.float64)

	def read_formula(self, data):
		"""
		read_formula uses a parser generator (whose syntax is defined in Formula.g4) and reads the string input

		:param data: str input of the formula
		:return: the output pf object instances generated by the parser from MyVisitor class.
		""" 
		# lexer
		lexer = FormulaLexer(data)
		stream = CommonTokenStream(lexer)
		# parser
		parser = FormulaParser(stream)
		tree = parser.formula()
		# evaluator
		visitor = MyVisitor()
		output = visitor.visit(tree)
		return output

	def check_formulas(self, epistemic_state, formulas):
		"""
		Check the truth of a formula in an epistemic state

		:param epistemic_state: EpistemicState object - the state in which to check the formula
		:param formulas: list - the list of potential formulas to check
		:param arg: parser - the args from the parser
		:param out: bool - whether to return the truth value of the formula in the state

		:return: truth: bool - the truth value of the formula in the state
		""" 
		# for loop to read (lexer, parser, evaluator) and check if the formulas hold in the state 
		for x in formulas:
			data =  InputStream(x)
			output = self.read_formula(data)
			# Check formulas in state
			truth = epistemic_state.truth(output)[1]
			return truth


	def take_obs(self, state):
		self.observation = {**self.locations, **self.propositions}
		for key in self.observation:
			if self.check_formulas(state, [key]):
				self.observation[key] = 1
		obs = np.asarray([self.observation[item] for item in sorted(self.observation)]).astype(np.float64)
		return obs

	def reset(self):
		"""
		Important: the observation must be a numpy array
		:return: (np.array) 
		"""
		# Initialize the agent at the failed state
		self.state = self.initial_state
		
		# here we convert to float64 to make it more general (in case we want to use continuous actions)
		return self.take_obs(self.initial_state)

	def step(self, action_id):

		info = {}

		if action_id == self.actions_id['Take_left']:
			if self.check_formulas(self.state, ['¬(f)&e']):
				event = {"Eps":["E","Ref","pre","post"], "Ed":["Take_left"], "E":["Take_left", "Take_leftf"], "Rep":[["Take_left","Take_left"],["Take_leftf","Take_leftf"]], "Ref":[["Take_left","Take_left"],["Take_leftf","Take_leftf"]], "pre":[["Take_left",["¬o","¬d","¬r","l"]],["Take_leftf",["¬o","¬d","¬r","l"]]], "post":[["Take_left",["d"]], ["Take_left",["¬d"]]]}
			else:
				event = {"Eps":["E","Ref","pre","post"], "Ed":["Take_left"], "E":["Take_left", "Take_leftf"], "Rep":[["Take_left","Take_left"],["Take_leftf","Take_leftf"]], "Ref":[["Take_left","Take_left"],["Take_leftf","Take_leftf"],["Take_left","Take_leftf"],["Take_leftf","Take_left"]], "pre":[["Take_left",["¬o","¬d","¬r","l"]],["Take_leftf",["¬o","¬d","¬r","l"]]], "post":[["Take_left",["d"]], ["Take_left",[""]]]}
		elif action_id == self.actions_id['Take_right']:
			if self.check_formulas(self.state, ['¬(f)&e']):
				event = {"Eps":["E","Ref","pre","post"], "Ed":["Take_right"], "E":["Take_right", "Take_rightf"], "Rep":[["Take_right","Take_right"],["Take_rightf","Take_rightf"]], "Ref":[["Take_right","Take_right"],["Take_rightf","Take_rightf"]], "pre":[["Take_right",["¬o","¬d","r","l"]],["Take_rightf",["¬o","¬d","r","l","¬(f)","e"]]], "post":[["Take_right",["d"]], ["Take_right",[""]]]}
			else:
				event = {"Eps":["E","Ref","pre","post"], "Ed":["Take_right"], "E":["Take_right", "Take_rightf"], "Rep":[["Take_right","Take_right"],["Take_rightf","Take_rightf"]], "Ref":[["Take_right","Take_right"],["Take_rightf","Take_rightf"],["Take_right","Take_rightf"],["Take_rightf","Take_right"]], "pre":[["Take_right",["¬o","¬d","r","l"]],["Take_rightf",["¬o","¬d","r","l","¬(f)","e"]]], "post":[["Take_right",["d"]], ["Take_right",[""]]]}
		elif action_id == self.actions_id['Throw_pebble']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["Throw_pebble"], "E":["Throw_pebble","Throw_pebblef"], "Rep":[["Throw_pebble","Throw_pebble"],["Throw_pebblef","Throw_pebblef"],["Throw_pebble","Throw_pebblef"],["Throw_pebblef","Throw_pebble"]], "Ref":[["Throw_pebble","Throw_pebble"],["Throw_pebblef","Throw_pebblef"],["Throw_pebble","Throw_pebblef"],["Throw_pebblef","Throw_pebble"]], "pre":[["Throw_pebble",["o","f"]],["Throw_pebblef",["o","f"]]], "post":[["Throw_pebble",[""]],["Throw_pebblef",[""]]]}
		elif action_id == self.actions_id['Flick_light']: 
			if self.check_formulas(self.state, ['¬(f)&e']):
				event = {"Eps":["E","Ref","pre","post"], "Ed":["Flick_light"], "E":["Flick_light", "Flick_lightf"], "Rep":[["Flick_light","Flick_light"],["Flick_lightf","Flick_lightf"]], "Ref":[["Flick_light","Flick_light"],["Flick_lightf","Flick_lightf"]], "pre":[["Flick_light",["¬o","e"]],["Flick_lightf",["¬o","e"]]], "post":[["Flick_light",["l"]], ["Flick_light",[""]]]}
			else:
				event = {"Eps":["E","Ref","pre","post"], "Ed":["Flick_light"], "E":["Flick_light", "Flick_lightf"], "Rep":[["Flick_light","Flick_light"],["Flick_lightf","Flick_lightf"]], "Ref":[["Flick_light","Flick_light"],["Flick_lightf","Flick_lightf"],["Flick_light","Flick_lightf"],["Flick_lightf","Flick_light"]], "pre":[["Flick_light",["¬o","e"]],["Flick_lightf",["¬o","e"]]], "post":[["Flick_light",["l"]], ["Flick_light",[""]]]}
		elif action_id == self.actions_id['MoveIn']: 
			event = {"Eps":["E","Ref","pre","post"], "Ed":["MoveIn"], "E":["MoveIn"], "Rep":[["MoveIn","MoveIn"]], "Ref":[["MoveIn","MoveIn"]], "pre":[["MoveIn",["o"]]], "post":[["MoveIn",["¬o"]]]}
		elif action_id == self.actions_id['MoveOut']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["MoveOut"], "E":["MoveOut"], "Rep":[["MoveOut","MoveOut"]], "Ref":[["MoveOut","MoveOut"]], "pre":[["MoveOut",["¬o"]]], "post":[["MoveOut",["o"]]]}
		elif action_id == self.actions_id['Cut_electricity']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["Cut_electricity"], "E":["Cut_electricity"], "Rep":[["Cut_electricity","Cut_electricity"]], "Ref":[["Cut_electricity","Cut_electricity"]], "pre":[["Cut_electricity",[""]]], "post":[["Cut_electricity",["¬l", "¬e", "f"]]]}
		elif action_id == self.actions_id['Use_battery']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["Use_battery"], "E":["Use_battery"], "Rep":[["Use_battery","Use_battery"]], "Ref":[["Use_battery","Use_battery"]], "pre":[["Use_battery",["¬e"]]], "post":[["Use_battery",["e"]]]}
		elif action_id == self.actions_id['Throw_pebble_check_fox']:
			event = {"Eps":["E","Ref","pre","post"], "Ed":["Throw_pebble_check_fox"], "E":["Throw_pebble_check_fox","Throw_pebble_check_foxf"], "Rep":[["Throw_pebble_check_fox","Throw_pebble_check_fox"],["Throw_pebble_check_foxf","Throw_pebble_check_foxf"]], "Ref":[["Throw_pebble_check_fox","Throw_pebble_check_fox"],["Throw_pebble_check_foxf","Throw_pebble_check_foxf"],["Throw_pebble_check_fox","Throw_pebble_check_foxf"],["Throw_pebble_check_foxf","Throw_pebble_check_fox"]], "pre":[["Throw_pebble_check_fox",["o","f"]],["Throw_pebble_check_foxf",["o","f"]]], "post":[["Throw_pebble_check_fox",[""]],["Throw_pebble_check_foxf",["¬d"]]]}

		epistemic_event = EpistemicEvent(event)
		state_copy = copy.deepcopy(self.state)

		if epistemic_event.rule_Wprime(state_copy, check_Ed=True): # If event applicable in current state
			self.state = EpistemicState(epistemic_event.compute(state_copy))
			obs = self.take_obs(self.state)
			if self.check_formulas(self.state, ['Opf(d)']):
				if self.display:
					print("-------------------< Red fox caught Pink Panther! >-------------------")
				reward = -100.
				done = True
				info.update({'is_success': False})
				if self.NotLearning:
					info.update({"Epistemic_state": self.state})
				return obs, reward, done, info
			if type(self.goal) == str:
				if self.check_formulas(self.state, [self.goal]):
					reward = 100.
					done = True
				else:
					reward = -1.
					done = False
				success = done
			else:
				comparison = (obs == self.goal).all() # Test if reached the goal

				reward = 100. if comparison else -1.
				done = (reward == 100.)
				success = done
		else:
			obs = self.take_obs(self.state)
			reward = -20.
			done = True
			success = False

		
		if self.display:
			if success:
				print('----------------------Congratz Robot! You succeded!---------------------------')
			else:
				print('It happens to fail!')

		info.update({'is_success': success}) 	# Optionally we can pass additional info, we are not using that for now

		if self.NotLearning:
			info.update({"Epistemic_state": self.state})

		return obs, reward, done, info


	def close(self):
		pass
	